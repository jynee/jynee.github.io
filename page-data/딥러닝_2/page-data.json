{"componentChunkName":"component---src-templates-post-tsx","path":"/딥러닝_2/","result":{"data":{"markdownRemark":{"html":"<h1 id=\"딥러닝-dl\" style=\"position:relative;\"><a href=\"#%EB%94%A5%EB%9F%AC%EB%8B%9D-dl\" aria-label=\"딥러닝 dl permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>딥러닝 DL</h1>\n<ul>\n<li>RNN</li>\n<li>CNN</li>\n</ul>\n<br>\n<br>\n<h2 id=\"순환-신경망rnn\" style=\"position:relative;\"><a href=\"#%EC%88%9C%ED%99%98-%EC%8B%A0%EA%B2%BD%EB%A7%9Drnn\" aria-label=\"순환 신경망rnn permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>순환 신경망(RNN)</h2>\n<ul>\n<li>hidden 층에서 서로 값을 기억해 순환한다.</li>\n<li>지금까진 FNN(feed forward neword) + 순서가 필요 없는 data를 써서 모델이 기억할 필요가 없었지만, 문장 같은 data를 쓸 땐 <strong>순서가 중요한 data(Sequence Data)를 가지고 미래를 예측해야 한다.</strong></li>\n<li>학습(트레이닝) 방법: 순서가 있는 data를 모델이 ‘기억’하게 만드는 것</li>\n<li>RNN 기본 입력은 3d 형태. D1=time, d2=feature, d0=data</li>\n<li>RNN 문제점: 기울기 소실 문제(vanishing gradient)가 FFN보다 더 심해짐</li>\n</ul>\n<br>\n<br>\n<h3 id=\"lstm\" style=\"position:relative;\"><a href=\"#lstm\" aria-label=\"lstm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LSTM</h3>\n<ul>\n<li>RNN의 vanishing gradient 해결을 위해 고안. C 추가<br></li>\n<li>\n<p>f와 i의 가중평균 형태<br></p>\n<div class=\"gatsby-highlight\" data-language=\"batch\"><pre class=\"language-batch\"><code class=\"language-batch\"><span class=\"token command\"><span class=\"token keyword\">f</span>: forget date. 이전의 C를 얼마나 반영할 것인지 조절</span>\n<span class=\"token command\"><span class=\"token keyword\">i</span>: input or ignore. 현재 입력값(x</span><span class=\"token punctuation\">)</span>과 이전의 출력값<span class=\"token punctuation\">(</span><span class=\"token command\"><span class=\"token keyword\">h</span></span><span class=\"token punctuation\">)</span>를 얼마나 반영할 것인지 조절\n\n* h는 위, 왼쪽 / c는 왼쪽으로 전파. 둘다 처음엔 0으로 시작함</code></pre></div>\n</li>\n<li>GRU: LSTM 구조를 간결하게 만듦. 속도도 더 빠르지만 성능도 안 떨어짐 <br></li>\n<li>\n<p>학습 유형: 단방향(FNN,BFN) / 양방향(FNN+BFN) 모두 적용 가능.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 572px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1fd151e537c9dbae72645f58985cffd3/a805e/image-20200816004535796.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.08108108108108%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABTklEQVQY0yWRic7aMBCEef9Xq0T+ltAAIYdz2jkIgRAgB1/X1JJljz2amd3dlGVJGMVM05umbTmdA+JYYZcxWu4x2pgvfr1epGnCOQhJ0oxlXRmf4xfbbaqKTdMNhHkv9A9x0eMcG/ZBy3uamN4v+tuDc3plnmcew4PbfcQNLvwIL9VXEXyyO1/47bfk1Y1N23WovBC9D7mp8MTJV4kknmkuNWmRooqSZV6oGkOhc46R4m8QUUlFTxH8jyVh09iENYmJbEBxSNiFW47JnmVZCAsf5/RL/kM+60fePf6EjpwubuSg24JxHDkI3sc/X7zpxaVSilWKbrOUWmuufS8JJ6o4Ijt41IliFoMyCMgFGxVzkcqGYWB8DBT+idzz6GwP+7qmjSIbkM4SZQC2L9M8Ufs+meN8/1dh6MOBbLulEWzF7JDG+x3tupS7HZ0M+B8z5r8n/iUOUQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20200816004535796\"\n        title=\"image-20200816004535796\"\n        src=\"/static/1fd151e537c9dbae72645f58985cffd3/a805e/image-20200816004535796.png\"\n        srcset=\"/static/1fd151e537c9dbae72645f58985cffd3/12f09/image-20200816004535796.png 148w,\n/static/1fd151e537c9dbae72645f58985cffd3/e4a3f/image-20200816004535796.png 295w,\n/static/1fd151e537c9dbae72645f58985cffd3/a805e/image-20200816004535796.png 572w\"\n        sizes=\"(max-width: 572px) 100vw, 572px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>Many to one: 둘다 정보량이 TIME이 증가할수록 높아진다. 따라서 높은 정보량끼리 마지막에 합친다</li>\n<li>Many to many</li>\n<li>\n<p>FNN 정보량이 TIME이 증가할수록 높아진다. </p>\n<p>BFN 정보량이 TIME이 증가할수록 낮아진다.</p>\n<p>따라서 각 뉴런에서 latent layer로 이어지는 정보량(마지막에 FNN정보량+BFN정보량)은 같다</p>\n</li>\n<li>One to many</li>\n<li>Many to many<br></li>\n</ol>\n</li>\n<li>\n<p>단방향은 ‘이후’만 기억, 양방향은 ‘이전’+’이후’ 모두 기억</p>\n<ul>\n<li>어떻게? 단방향은 FBN만 사용, 양방향은 FBN+BFN 사용하기 떄문.<br></li>\n</ul>\n</li>\n<li>\n<p>양방향(FNN+BFN) 진행 순서: </p>\n<ol>\n<li>모델(code)에서(RNN층 내) FNN 진행 후 정보량 모아두고, </li>\n<li>BFN 진행 후 정보량 모아두고,</li>\n<li>CONCAT(합침)해서 </li>\n<li>error를 역전파 시킴 <br></li>\n</ol>\n</li>\n<li>\n<p>FNN VS BFN:</p>\n<ul>\n<li>FNN : TIME이 낮->높</li>\n<li>BFN : TIME이 높->낮</li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n<h2 id=\"cnn\" style=\"position:relative;\"><a href=\"#cnn\" aria-label=\"cnn permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CNN</h2>\n<ul>\n<li>\n<p>사람의 시각인지 과정을 모방해서 피드포워드 신경망에 추가</p>\n<ul>\n<li>이미지를 분류한다 치면, 이미지의 부분적 특성에 주목해 분류하여 FFN에 넣는 것 </li>\n<li>\n<p>이미지 분석에 활용: 이미지를 대표할 수 있는 특성들을 도출해서 신경망에 넣어준다.</p>\n<br>\n</li>\n</ul>\n</li>\n<li>\n<p>순서 </p>\n<p>특성 추출 → 클래스 분류\n→ <strong>컨볼루션</strong> 또는 필터링 과정\n→ <strong>특성지도</strong> 출력\n→ 서브샘플링(subsampling) 또는 <strong>풀링</strong>(pooling)\n→ 다시 컨볼루션, 활성화, 서브샘플링을 수행\n→ 최종 특성지도는 피드포워드 신경망에 입력되어 분류 작업을 시행<br></p>\n<div class=\"gatsby-highlight\" data-language=\"batch\"><pre class=\"language-batch\"><code class=\"language-batch\">컨볼루션: \n<span class=\"token command\"><span class=\"token keyword\">image</span> data의 경우</span>\n→ filter<span class=\"token punctuation\">(</span><span class=\"token command\"><span class=\"token keyword\">kernel</span>: image data와의 convolution(cross-correlation</span><span class=\"token punctuation\">)</span> 진행<span class=\"token punctuation\">)</span> \n→ feature map 생성<span class=\"token punctuation\">(</span>기호에 따라 zero padding, ReLU와 같은 활성함수 적용 가능<span class=\"token punctuation\">)</span>\n→ <span class=\"token punctuation\">(</span><span class=\"token command\"><span class=\"token keyword\">max</span><span class=\"token parameter attr-name\">/mean</span></span><span class=\"token punctuation\">)</span> pooling \n→ feature map 생성<span class=\"token punctuation\">(</span>출력<span class=\"token punctuation\">)</span> \n→ flatten<span class=\"token punctuation\">(</span>: 1D구조로 만듦<span class=\"token punctuation\">)</span> \n→ FNN</code></pre></div>\n</li>\n</ul>\n<br>\n<ol>\n<li>입력된 이미지로부터 이미지의 고유한 특징을 부각시킨 특성지도(feature map)를 새로 만듦</li>\n<li>그 이미지는 피드포워드 신경망에 입력되어 이미지가 어떤 클래스 라벨에 속하는지 분류</li>\n<li>학습: (grid serch) 수평 엣지 필터, 수직 엣지 필터 컨볼루션</li>\n<li>ReLU와 같은 활성함수를 거쳐 특성지도 출력</li>\n<li>서브샘플링(subsampling) 또는 풀링(pooling) 통해 활성화된 특성지도들의 크기를 줄임</li>\n<li>(저차원적인 특성부터 시작해서 고차원적인 특성을 도출)이 특성지도들에 다시 컨볼루션, 활성화, 서브샘플링을 수행하여 로컬한 특성지도로부터 글로벌한 특성지도를 만들어간다.</li>\n<li>이 과정을 여러번 반복하여 얻어진 최종 특성지도는 fully-connected layer, 즉 피드포워드 신경망에 입력되어 분류 작업을 시행</li>\n</ol>\n<br>\n<ul>\n<li>\n<p>용어</p>\n<ul>\n<li><code class=\"language-text\">feature map</code>: 이미지의 부분적 특징을 모아놓은 것의 집합</li>\n<li><code class=\"language-text\">padding</code>:</li>\n<li><code class=\"language-text\">convolution layer</code>: convolution(cross-correlation) 진행되는 곳 </li>\n<li><code class=\"language-text\">upsampling</code>: pooling layer와 달리 차원을 줄이는 게 아니라 차원을 늘림. Autoencoder의 decoder와 같은 곳에서 원래 데이터로 복원할 때 사용됨. Zero padding은 가생이를 0으로 채우는데 sampling은 무슨 계산을 해서 채우는 듯하다.  </li>\n</ul>\n</li>\n</ul>\n<br>\n<h3 id=\"코딩-용어-설명\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%94%A9-%EC%9A%A9%EC%96%B4-%EC%84%A4%EB%AA%85\" aria-label=\"코딩 용어 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코딩 용어 설명</h3>\n<ul>\n<li>\n<p>컨볼루션 레이어 단계</p>\n<ul>\n<li><code class=\"language-text\">Filters</code>: 출력 모양의 깊이(depth) 를 결정<br></li>\n<li><code class=\"language-text\">kernel_size</code>: </li>\n<li>w(연결선, 가중치)이자, filter의 size.</li>\n<li>\n<p>연산을 수행할 때 윈도우의 크기</p>\n<ul>\n<li>2D에서 kernel_size=(8,1)이면 8행+1열(이때 1열은 feature)</li>\n<li>1D에서 kernel_sizw=8이면 자동 8행+전체열(1D에서 필터는 아래 방향으로 밖에 이동 못함)<br></li>\n</ul>\n</li>\n<li><code class=\"language-text\">strides</code>: 필터 적용 시 한 번에 얼마나 움직일지(이동 크기) 이동할 칸 수. 보통 1을 씀. <br></li>\n<li><code class=\"language-text\">padding</code>: </li>\n<li>\n<p>컨볼루션 레이어(합성곱) 혹은 풀링 연산을 수행하는 레이어에 파라미터로 설정</p>\n<p>convolution과 pooling 연산은 파라미터의 수를 줄여나가는 과정이다. 하지만 이러한 과정에서 지나치게 데이터가 축소되어 정보가 소실되는 것을 방지하기 위해 데이터에 0으로 이루어진 패딩을 주는 경우가 있다.</p>\n</li>\n<li>\n<p>‘원본’(사이즈)을 조정. filter를 거치면 이미지 사이즈가 원본과 달리 작아지는데, 이를 피하기 위해 작아지는 사이즈가 원본 사이즈만큼 되도록 원본 사이즈 크기를 늘림. 이때, Zero padding 기법을 사용. 수치(?)가 없는 부분 즉, 가생이(모서리)을 ‘0’으로 채움(가생이 아니고 중간 부분 채워도 zero-padding)<br></p>\n<ol>\n<li><code class=\"language-text\">padding = &#39;same&#39;</code>: 원본 사이즈 유지시킴(차원 유지)</li>\n<li>원리: 필터의 사이즈가 k이면 사방으로 k/2 만큼의 패딩을 준다.</li>\n<li><code class=\"language-text\">padding = &#39;valid&#39;</code>: 패딩 사용하지 않음 <br></li>\n</ol>\n</li>\n<li><code class=\"language-text\">activation: ‘ReLu’</code>가 default. CNN에선 ReLu 사용을 권장한다고 함 </li>\n</ul>\n <br>\n</li>\n<li>\n<p><code class=\"language-text\">pooling</code> 단계</p>\n<ul>\n<li>원본이미지에서 특징 추출해서 feature map의 크기를 줄여주는 과정. </li>\n<li>(1) Max pooling, (2) mean pooling이 있음 </li>\n<li>pool<em>size: strides가 미리 설정되지 않을 경우 pool</em>size와 동일하게 설정된다. <br></li>\n<li>strides</li>\n<li>padding<br></li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">Flatten</code> 단계</p>\n<ul>\n<li>Flatten<br></li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">output</code> 단계</p>\n<ul>\n<li>Dense(n, activation = )</li>\n</ul>\n</li>\n</ul>\n <br>\n <br>\n<h2 id=\"차원-참고\" style=\"position:relative;\"><a href=\"#%EC%B0%A8%EC%9B%90-%EC%B0%B8%EA%B3%A0\" aria-label=\"차원 참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>차원 참고</h2>\n<ul>\n<li>1차원 벡터: shape(2,)</li>\n<li>2차원 Matrix : shape(행,열)</li>\n<li>3차원: shape(면, 행, 열) = D0, D1, D2</li>\n<li>4차원: shape (samples, rows, cols, channels) = D0, D1, D2 ,D3 </li>\n</ul>\n <br>\n<br>\n <br>\n<br>\n<blockquote>\n<p>참고: </p>\n<ul>\n<li>아마퀀트. 2019. 7. 19. \"Keras LSTM** 유형 정리 (2/5) – 단층-단방향 &#x26; many-to-many 유형\". <a href=\"http://blog.naver.com/chunjein/221589624838\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://blog.naver.com/chunjein/221589624838</a>. 아마추어 퀀트 (Amateur Quant).</li>\n<li>chrisysl. 2018. 9. 10. \"3. Convolutional Networks / L2. Convolutional Neural Networks - Convolutional Layers in Keras\". <a href=\"https://kevinthegrey.tistory.com/141\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://kevinthegrey.tistory.com/141</a></li>\n<li>심교훈. 2019. 3. 1. \"딥러닝 알고리즘의 대세, 컨볼루션 신경망(convolutional neural network, CNN)\". <a href=\"https://bskyvision.com/412?category=635506b\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://bskyvision.com/412?category=635506b</a>. 스카이비전</li>\n<li>Seongyun Byeon. 2018.01.23. 딥러닝에서 사용되는 여러 유형의 Convolution 소개\". <a href=\"https://zzsza.github.io/data/2018/02/23/introduction-convolution/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://zzsza.github.io/data/2018/02/23/introduction-convolution/</a>. 어쩐지 오늘은</li>\n</ul>\n</blockquote>","excerpt":"딥러닝 DL RNN CNN 순환 신경망(RNN) hidden 층에서 서로 값을 기억해 순환한다. 지금까진 FNN(feed forward neword) + 순서가 필요 없는 data를 써서 모델이 기억할 필요가 없었지만, 문장 같은 data…","tableOfContents":"<ul>\n<li>\n<p><a href=\"/%EB%94%A5%EB%9F%AC%EB%8B%9D_2/#%EB%94%A5%EB%9F%AC%EB%8B%9D-dl\">딥러닝 DL</a></p>\n<ul>\n<li>\n<p><a href=\"/%EB%94%A5%EB%9F%AC%EB%8B%9D_2/#%EC%88%9C%ED%99%98-%EC%8B%A0%EA%B2%BD%EB%A7%9Drnn\">순환 신경망(RNN)</a></p>\n<ul>\n<li><a href=\"/%EB%94%A5%EB%9F%AC%EB%8B%9D_2/#lstm\">LSTM</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/%EB%94%A5%EB%9F%AC%EB%8B%9D_2/#cnn\">CNN</a></p>\n<ul>\n<li><a href=\"/%EB%94%A5%EB%9F%AC%EB%8B%9D_2/#%EC%BD%94%EB%94%A9-%EC%9A%A9%EC%96%B4-%EC%84%A4%EB%AA%85\">코딩 용어 설명</a></li>\n</ul>\n</li>\n<li><a href=\"/%EB%94%A5%EB%9F%AC%EB%8B%9D_2/#%EC%B0%A8%EC%9B%90-%EC%B0%B8%EA%B3%A0\">차원 참고</a></li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/딥러닝_2/"},"frontmatter":{"title":"딥러닝 LSTM&CNN","date":"Jul 14, 2020","tags":["DL","LSTM","CNN"],"keywords":["JyneeEarth","jynee"],"update":"Aug 16, 2020"}}},"pageContext":{"slug":"/딥러닝_2/","series":[{"slug":"/딥러닝_1/","title":"딥러닝 기초","num":1},{"slug":"/딥러닝_2/","title":"딥러닝 LSTM&CNN","num":2}],"lastmod":"2020-08-16"}},"staticQueryHashes":["3649515864","694178885"]}
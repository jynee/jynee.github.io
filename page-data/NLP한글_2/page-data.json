{"componentChunkName":"component---src-templates-post-tsx","path":"/NLP한글_2/","result":{"data":{"markdownRemark":{"html":"<h1 id=\"텍스트-분류\" style=\"position:relative;\"><a href=\"#%ED%85%8D%EC%8A%A4%ED%8A%B8-%EB%B6%84%EB%A5%98\" aria-label=\"텍스트 분류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>텍스트 분류</h1>\n<ul>\n<li>Skip-Gram</li>\n<li>SGNS</li>\n<li>Hirarchical softmax</li>\n</ul>\n<br>\n<br>\n<h2 id=\"code-classlanguage-texthirarchical-softmaxcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-texthirarchical-softmaxcode\" aria-label=\"code classlanguage texthirarchical softmaxcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">Hirarchical softmax</code></h2>\n<ul>\n<li>연산이 많아진단 단점의 softmax를 개선하여 Binary Tree 사용<br></li>\n<li>\n<p>Binary Tree</p>\n<ul>\n<li>iForest 알고리즘, DB indexing</li>\n<li>각 트리마다 나눠서 연산을 함 <br></li>\n</ul>\n</li>\n<li>\n<p>순서</p>\n<ul>\n<li>vocab 생성 단계에서 단어들을 sort</li>\n<li>출력층을 binary (huffman) tree</li>\n<li>y와 yHat 사이의 차이를 줄이는 방향으로 역전파 </li>\n<li>기존 softmax는 yHat(확률분포 형태)를 구하는 부분에서 계산량이 많다. 이걸 binary tree를 사용하는 것.</li>\n<li>\n<p>그렇게 되면 기존 yHat은 0.01, 0.03 ... 등으로 출력됐는데, 0.6, 0.42 등으로 출력되어 기존의 방법보다 계산량이 작아져 속도도 빨라진다.</p>\n<br>\n</li>\n</ul>\n</li>\n<li>\n<p>word2vec</p>\n<ul>\n<li><strong>의미 공간이라는 고차원의 공간에 각 단어의 좌표값(벡터)을 부여한다</strong></li>\n<li>기준점이 달라지면 숫자도 달라지는 상대적인 거리로 단어 간의 유사도/차이를 분석할 수 있다.</li>\n</ul>\n<br>\n</li>\n</ul>\n<br>\n<h1 id=\"code-classlanguage-textpv-dmcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textpv-dmcode\" aria-label=\"code classlanguage textpv dmcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">PV-DM</code></h1>\n<ul>\n<li>paragraph vector<br></li>\n<li>\n<p><code class=\"language-text\">doc2vec</code>에 사용됨</p>\n<ul>\n<li>distributed word representation(분포확률/가설 이론 사용)</li>\n<li>한 문장에 같이 쓰인 단어들끼리의 유사성이 높을 것이란 가설 이론<br></li>\n</ul>\n</li>\n<li>\n<p>word vector 가 아닌 paragraph 단위의 vector 표현</p>\n<ul>\n<li>paragraph : 문장, 문서 단위<br></li>\n</ul>\n</li>\n<li>word2vec → (발전 시킴) Doc2vec</li>\n<li>USL</li>\n<li>유사도 계산에 순서 고려까지 하는 알고리즘 </li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fc07fc23018e5c3f755208039dfa5ea2/58213/image-20200805181033974.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.54054054054054%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABU0lEQVQoz4WSW0/CQBCF+/9/ic8+GIgx0QcTiZeIXFQQsEXkUi6FlnbbvXxuFzD4gpNMZjN7ZnbOnPWMMZxySgd3FmqfY5c7WJpq5+Wdxz8W29rRVtPbSM4GGaPMMMkNzUiy3hYO0+/l3NcyhNB4ShqyTDOZSJJEMw+Vi1JY8Pgb+ekzSyUzixnEivUqZR2ltHxB7WGNLAzRSjEMCpRl4IUzRbeTU8bJWHJ9ldB81YR37+D3MdMQuUrodBRBM4LLCqvzGx5uE1qNwtZJR/drKMlzO2E5zWKhXEOtDW9twTKyPOMIMx6TBjOmfsJHT9LrCgJLu93IqFa2lmZK4BeMviSbjXZMvePFmr0ApRCHtRv7SBzvwEIY51JBFCmH39qBPro5y6VyeO9XzUODI1WP839tly8ZvdQF1YuEp8fMNfZOfpdT38laYdWeh9I2Tak/C6fBD1kSaS7IbENYAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20200805181033974\"\n        title=\"image-20200805181033974\"\n        src=\"/static/fc07fc23018e5c3f755208039dfa5ea2/fcda8/image-20200805181033974.png\"\n        srcset=\"/static/fc07fc23018e5c3f755208039dfa5ea2/12f09/image-20200805181033974.png 148w,\n/static/fc07fc23018e5c3f755208039dfa5ea2/e4a3f/image-20200805181033974.png 295w,\n/static/fc07fc23018e5c3f755208039dfa5ea2/fcda8/image-20200805181033974.png 590w,\n/static/fc07fc23018e5c3f755208039dfa5ea2/efc66/image-20200805181033974.png 885w,\n/static/fc07fc23018e5c3f755208039dfa5ea2/58213/image-20200805181033974.png 902w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<blockquote>\n<p>그림 출처: 아마추어 퀀트, blog.naver.com/chunjein<br></p>\n</blockquote>\n<ul>\n<li>concat 후 lstm 넣으면 정보가 조금은 유실된 채로 넣어지는 것이라 우리는 지금까지 embeding layer 거친 것을 바로 lstm으로 넣었음.</li>\n</ul>\n<br>\n<ul>\n<li>\n<p>원리: </p>\n<ul>\n<li>문장 -1 \"doc#1\" : the cat sat on the table 가 있을 때,</li>\n<li>문장마다 unique한 ID(Paragraph id)를 붙여놓고 이것도 하나의 문장으로 취급함.</li>\n<li>\n<p><code class=\"language-text\">paragraph vector</code></p>\n<ul>\n<li>이것들이 추후엔 word가 됨</li>\n<li>즉, paragraph token은 또 다른 word라 생각하면 됨 </li>\n<li>모든 문장의 paragraph vector를 공유함 <br></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>따라서</p>\n<ul>\n<li>concat으로 합쳐져서 y 값이 나오도록 역전파</li>\n<li>x의 fix value는 3, y는 1라면, window size = 4로 설정</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>context</th>\n<th>x(vocab의 index로 입력)</th>\n<th>y(vocab의 index로 출력)</th>\n<th>missing value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>doc - # 1(7)</td>\n<td>the(1), cat(3), sat(4)</td>\n<td>on(13)</td>\n<td></td>\n</tr>\n<tr>\n<td>doc - # 1(7)</td>\n<td>cat(3), sat(4), on(13)</td>\n<td>table(8)</td>\n<td>the(1)</td>\n</tr>\n</tbody>\n</table>\n<p>이렇게 학습 시킨다.</p>\n<blockquote>\n<p>*'이렇게 학습' : Distributed memory model of paragraph vector(PV-DM): missing된 값을 기억한다</p>\n</blockquote>\n</li>\n</ul>\n<br>\n<ul>\n<li>학습 후에는 paragraph vector가 1개의 colum vector(word vector)가 됨<br></li>\n<li>단점: 학습 단계는 괜찮은데, prediction 단계에서는 새 문장에 paragraph id를 알 수 없어 값을 넣지 못한다는 점<br></li>\n<li>\n<p>해결: inference step(추론 단계) 필요</p>\n<ul>\n<li>학습에 사용되지 않은 문장에 대해서는 inference step이 필요하다.</li>\n<li>GD 방법에 의해 얻을 수 있다.<br></li>\n</ul>\n</li>\n<li>\n<p>따라서 알고리즘 순서: </p>\n<ul>\n<li>2개의 주 Stage가 있다.</li>\n<li>W, D, U 결정(학습단계) 및 고정</li>\n<li>\n<p><strong>inferece stage</strong>가 필요</p>\n<ul>\n<li>GD(학습) 통해 알아냄. </li>\n<li>위에서 학습 완료된 W(embedding layer 거친 word vector), U(softmax 가중치), b(softmax의 bias) 고정 시킴</li>\n<li>일반적으론 model.fit(x, y)로 학습 한 후, model.predict(x)로 예측했는데 </li>\n<li>\n<p>inference 때에는 D(paragraph Matrix) 값을 모르니 D를 random하게 둔다</p>\n<ul>\n<li>따라서 model.fit(x, y)로 학습 한 후, model.predict(new x) 수행</li>\n<li>advantage paragraph vector </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>PV-DM에서는 다음과 같은 크게 두 가지 단계를 거쳐서 문장의 발화 의 도를 예측한다. </p>\n<ol>\n<li>주어진 데이터로 W(word vectors), U(softmax weights), b(softmax weights), D(paragraph vectors)를 학습한다. </li>\n<li>새로운 문장에 대해서 이미 학습했던 W, U, b는 유지하면서 D에 column을 추가하고 기울기 하강기법(gradient descent)을 적용하여 새로운 문장에 대한 벡터(D’)을 만들게 된다.\n두 번째 단계에서 얻은 D’은 인식기를 통해 미리 정의한 발화 의도 집합 중 하나로 분류된다</li>\n</ol>\n<p>출처: 최성호, 김은솔, 장병탁. 2016. Paragraph Vector를 이용한 문장 의도 예측 기법. 2016년 한국컴퓨터종합학술대회 논문집</p>\n</blockquote>\n</li>\n</ul>\n<br>\n<br>\n<h1 id=\"code-classlanguage-textpv-dbowcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textpv-dbowcode\" aria-label=\"code classlanguage textpv dbowcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">PV-DBOW</code></h1>\n<ul>\n<li>PV-DM과 반대 </li>\n</ul>\n<br>\n<h2 id=\"cnn--lstm\" style=\"position:relative;\"><a href=\"#cnn--lstm\" aria-label=\"cnn  lstm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CNN &#x26; LSTM</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/dbea49c77f57e710c7c2132d49463002/73fd0/image-20200805175130043.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 141.2162162162162%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsSAAALEgHS3X78AAAD30lEQVRIx41ViW7bVhDk//9G/qAfUARBERQoYjuOncSyJMqSJVEU7/vezCz5ZKp1gBJYUTzevNnZ2aUl09H3A6KXYRDEoGGO+bX5P4/5YTUAaRHT0qszNynL7gr4vWMObt0FqdwEiXj7RGw7kMMhliSuxPdz8c6ZfL11ZLMJxPNyqaoWzxPZvkTyuovl9TWWuuqkbTvNrut6sfK6lbRqJM9qiaNSiqJRQHsdSJbWctjH8vOHK0VeK/O/P2/l459r+evTC2Ir61UgSVJJ23XSNJ1YPVAZnca4E48wGNktngIwCmVjh5JiIVnznbOb6f0ahLgR75GpRRCC8YI7dDifTrkEQa4sH7458vTTk+VzKLc3R9ltI/G9Qs5nStBIHJcqB8+actO0CtRgJ+5GYHsdaqqUwPcypEQpal2YQZrNJpS7m738+O5qPD6c9MxnlqY6CWrEZbUIvnz2xUVqZDK3TRSWkOIsD/cncU+ZAqVpNaWMnwFBgBpVNEzJ/HhMNLUITMkyDAplSplaZDUMvcZFNhZln1fywXZU4AOsQ1sQOASLqmzk5KSyWvpazS//7JQZdSzL0QG7bah2urKNnWBnLC4RZGd2ZCWp52oZgGUB8Fhy2McAeNDXPSUXuTTlHj/Sz6rcdZeH1IbpsoJM+f6ro9dMk5IQ1NjlAtgCvWlHTUbA/hLGk2Tyuos0g6aeCifDu31tDVgo02CYg3E3sqVm3x9Pyo4ScFGGir6gHZfPnmq7ePLg22K0jZ0W8sWLxUc1z+gCtl6eNwrK7iAgDU1QVplZsNLPC0/ubo+y18LE0DdD/xdi3WMw/LF1FdBBRbkLBwOLsMMA2GMAsFdpoQVAvt07F6NT27H1ZLQPsrSGXgfgGDhqaESANC3Ru+gOMkeqNDOra1qMTEe/shhvUlnNVAxjZjJkhGGh/cz2Y1psOwJT6xjTaLdNwD66dIjBsUw1zQ68GU+dMXqyB7tCwch2LNabC+aFVIZqULz4sokgdIBhAC2PKeZfI8dDqkOUXTOKnmthzMZjut3Vf4s/JSpLANMF9BvTXjz5Okm42Xo1zsQtWo0b0ia2HSl7Xtt4RodcUiYAJzUnM20zWqQdJziKRE+yS1bw3WGfalYe5uIWluFmnAOqIRnRIvxOkJHjJGrWxwcXxg10hDHY0xxVfIfvMk64PrscxJFuTM0t/iSwQuAXqlMYlEghUXuQJUGYVjR9b8iCJKpyZP/2hZzZhgtoE/2iYTTRzATkfV6zgwIUhOOs/1dV5wWZvinX03r+wTHDgf37nkXeC8sgG3PPR5G53zbdf+7/Lq4AWdX/u/B38Qv7PW53wn67wAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20200805175130043\"\n        title=\"image-20200805175130043\"\n        src=\"/static/dbea49c77f57e710c7c2132d49463002/fcda8/image-20200805175130043.png\"\n        srcset=\"/static/dbea49c77f57e710c7c2132d49463002/12f09/image-20200805175130043.png 148w,\n/static/dbea49c77f57e710c7c2132d49463002/e4a3f/image-20200805175130043.png 295w,\n/static/dbea49c77f57e710c7c2132d49463002/fcda8/image-20200805175130043.png 590w,\n/static/dbea49c77f57e710c7c2132d49463002/73fd0/image-20200805175130043.png 793w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<blockquote>\n<p>그림 출처: 아마추어 퀀트, blog.naver.com/chunjein</p>\n</blockquote>\n<br>\n<ul>\n<li>\n<p><code class=\"language-text\">Word2vec</code> : LSTM/CNN</p>\n<ul>\n<li>위 그림 中 1번 그림이다.</li>\n<li>1개 문장 안에서 단어들의 sequence 분석한다.</li>\n<li>즉, 순서/흐름에 주목한 모델이다.<br></li>\n</ul>\n</li>\n<li>\n<p>부족한 부분은 padding 처리하며 time step을 통일 시켜주었다.</p>\n<ul>\n<li>\n<p><em>근데 \"time step의 크기를 굳이 통일시킬 필요가 있나?\" \"어떤 batch는 부족하면 안 되나? \"</em></p>\n<ul>\n<li>부족해도 된다. 경우에 따라 padding을 써주는데 쓰는 게 일반적이다. </li>\n</ul>\n<br>\n</li>\n</ul>\n<br>\n</li>\n<li>\n<p><code class=\"language-text\">Doc2vec</code>: </p>\n<ul>\n<li>위 그림 中 2번 그림일 때, batch가 문장 1개라 sequence 분석이 불가능</li>\n<li>기계가 입력값을 기억하지 못한다.</li>\n<li>\n<p>인공지능 로봇으로 따지면, </p>\n<p>나: \"지니야 내가 방금 뭐라고 그랬지?\"</p>\n<p>기계: \"무슨 말씀인지 모르겠어요.\"<br></p>\n</li>\n<li>따라서 3번 그림. <code class=\"language-text\">Episodic stroy</code>개념 사용하여 episode가 batch 역할을 한다. </li>\n<li>기계가 입력값을 기억할 수 있다. </li>\n<li>\n<p>인공지능 로봇으로 따지면, </p>\n<p>나: \"지니야 내가 방금 뭐라고 그랬지?\"</p>\n<p>기계: \"오늘 날씨가 어떠냐고 물어봤죠?\"</p>\n</li>\n<li>현재 개발이 되고는 있지만 쉽지 않은 영역이라 발전은 더딘 편이다.</li>\n<li>만약 개발이 된다면, A 작가의 40년치 소설을 모델에 넣어 학습 시켜 가지고 그 작가의 문체적 특징을 파악할 수 있지 않을까<em>?</em></li>\n</ul>\n<br>\n</li>\n<li>\n<p>원리: </p>\n<ol>\n<li>1개 episodic내에서 문장(문단)의 sequence 분석 시행</li>\n<li>LSTM layer에 입력</li>\n<li>chatbot의 경우: 대화 내용의 흐름이 존재. 이걸 학습하기 위해 (내가 챗봇과 대화하는 하나의 세션(대화주제) 개념으로의)episodic story 활용 </li>\n<li>\n<p>이때, time step을 굳이 지정해서 길이를 통일시키지 않아도 된다. </p>\n<blockquote>\n<p>x.shape = (None, 문장 개수, vector_size)</p>\n<p>xInput = Input(batch<em>shape = (None, <strong>None</strong>, vector</em>size))</p>\n<ul>\n<li>다만, 입력된 문장 개수에 따라 recurrent 횟수가 가변적이다.</li>\n<li>추후 학습 시: model.fit(x,y, batch_size=1) 필요.</li>\n<li>단점: 학습 시간이 오래 걸린다.</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n</li>\n</ul>\n<br>\n<br>\n<br>\n<br>\n<ul>\n<li>\n<p>참고: </p>\n<blockquote>\n<ul>\n<li>아마추어 퀀트, blog.naver.com/chunjein</li>\n<li>코드 출처: 전창욱, 최태균, 조중현. 2019.02.15. 텐서플로와 머신러닝으로 시작하는 자연어 처리 - 로지스틱 회귀부터 트랜스포머 챗봇까지. 위키북스</li>\n</ul>\n</blockquote>\n</li>\n</ul>","excerpt":"텍스트 분류 Skip-Gram SGNS Hirarchical softmax  연산이 많아진단 단점의 softmax를 개선하여 Binary Tree 사용 Binary Tree iForest 알고리즘, DB indexing…","tableOfContents":"<ul>\n<li>\n<p><a href=\"/NLP%ED%95%9C%EA%B8%80_2/#%ED%85%8D%EC%8A%A4%ED%8A%B8-%EB%B6%84%EB%A5%98\">텍스트 분류</a></p>\n<ul>\n<li><a href=\"/NLP%ED%95%9C%EA%B8%80_2/#code-classlanguage-texthirarchical-softmaxcode\"><code class=\"language-text\">Hirarchical softmax</code></a></li>\n</ul>\n</li>\n<li><a href=\"/NLP%ED%95%9C%EA%B8%80_2/#code-classlanguage-textpv-dmcode\"><code class=\"language-text\">PV-DM</code></a></li>\n<li>\n<p><a href=\"/NLP%ED%95%9C%EA%B8%80_2/#code-classlanguage-textpv-dbowcode\"><code class=\"language-text\">PV-DBOW</code></a></p>\n<ul>\n<li><a href=\"/NLP%ED%95%9C%EA%B8%80_2/#cnn--lstm\">CNN &#x26; LSTM</a></li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/NLP한글_2/"},"frontmatter":{"title":"NLP Doc2Vec","date":"Aug 05, 2020","tags":["NLP","Doc2Vec"],"keywords":["JyneeEarth","jynee"],"update":"Aug 18, 2020"}}},"pageContext":{"slug":"/NLP한글_2/","series":[{"slug":"/NLP한글_1/","title":"NLP 카운트 기반 방법의 텍스트 유사도 측정","num":1},{"slug":"/NLP한글_2/","title":"NLP Doc2Vec","num":2},{"slug":"/NLP한글_3/","title":"NLP Kaggle competition 우승자가 제안한 새로운 접근방법을 배워보자","num":3},{"slug":"/NLP한글_4/","title":"NLP maLSTM","num":4}],"lastmod":"2020-08-18"}},"staticQueryHashes":["3649515864","694178885"]}